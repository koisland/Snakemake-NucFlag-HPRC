
LOGS_DIR = config.get("logs_dir", "logs/nucflag")
BMKS_DIR = config.get("benchmarks_dir", "benchmarks/nucflag")
SAMPLE_INFO = {sm["name"]: sm for sm in config["samples"]}
MTYPES = {
    "GOOD": "135,206,235",
    "COLLAPSE_VAR": "0,0,255",
    "COLLAPSE": "0,255,0",
    "MISJOIN": "255,165,0",
    "HET": "0,128,128",
    "COLLAPSE_OTHER": "255,0,0"
}
VERSION = "v0.3.4"
DTYPE = "hifi"

wildcard_constraints:
    sm="|".join(SAMPLE_INFO.keys()),


module Align:
    snakefile:
        "rules/Snakemake-Aligner/workflow/Snakefile"
    config:
        {
            **config,
            "aligner": "pbmm2",
            "aligner_opts": "--log-level DEBUG --preset SUBREAD --min-length 5000 --strip",
            "logs_dir": LOGS_DIR,
            "benchmarks_dir": BMKS_DIR,
        }


use rule * from Align


rule get_chrom_sizes:
    input:
        asm_dir=lambda wc: SAMPLE_INFO[str(wc.sm)].get("asm_dir"),
    output:
        asm_fai=os.path.join(config["output_dir"], "{sm}.fa.fai")
    conda:
        "env/tools.yaml"
    shell:
        """
        samtools faidx <(zcat {input.asm_dir}/*.gz) -o - > {output.asm_fai}
        """


rule check_asm_nucflag:
    input:
        chrom_sizes=rules.get_chrom_sizes.output,
        bam_file=ancient(rules.merge_read_asm_alignments.output.alignment),
        # Optional arguments.
        regions=lambda wc: SAMPLE_INFO[str(wc.sm)].get("region_bed", []),
        config=lambda wc: SAMPLE_INFO[str(wc.sm)].get("config", []),
        ignore_regions=lambda wc: SAMPLE_INFO[str(wc.sm)].get("ignore_bed", []),
        overlay_regions=lambda wc: SAMPLE_INFO[str(wc.sm)].get("overlay_beds", []),
    output:
        plot_dir=directory(os.path.join(config["output_dir"], "{sm}")),
        cov_dir=(
            directory(os.path.join(config["output_dir"], "{sm}_coverage"))
            if config.get("output_coverage")
            else []
        ),
        misassemblies=os.path.join(
            config["output_dir"],
            "{sm}_misassemblies.bed",
        ),
        asm_status=os.path.join(
            config["output_dir"],
            "{sm}_status.bed",
        ),
    params:
        regions=lambda wc, input: f"-b {input.regions}" if input.regions else "",
        config=lambda wc, input: f"-c {input.config}" if input.config else "",
        ignore_regions=lambda wc, input: (
            f"--ignore_regions {input.ignore_regions}" if input.ignore_regions else ""
        ),
        overlay_regions=lambda wc, input: (
            f"--overlay_regions {' '.join(input.overlay_regions)}"
            if input.overlay_regions
            else ""
        ),
        output_coverage=lambda wc, output: (
            f"--output_cov_dir {output.cov_dir}"
            if config.get("output_coverage")
            else ""
        ),
    threads: config["processes_nucflag"]
    conda:
        "env/nucflag.yaml"
    resources:
        mem=config["mem_nucflag"],
    log:
        os.path.join(LOGS_DIR, "run_nucflag_{sm}.log"),
    benchmark:
        os.path.join(BMKS_DIR, "run_nucflag_{sm}.tsv")
    shell:
        """
        nucflag \
        -i {input.bam_file} \
        -d {output.plot_dir} \
        -o {output.misassemblies} \
        -t {threads} \
        -p {threads} \
        -s {output.asm_status} \
        --chrom_sizes {input.chrom_sizes} \
        {params.config} \
        {params.regions} \
        {params.ignore_regions} \
        {params.overlay_regions} \
        {params.output_coverage} &> {log}
        """

rule convert_nucflag_to_bed9:
    input:
        bed=rules.check_asm_nucflag.output.misassemblies
    output:
        bed=os.path.join(
            config["output_dir"],
            "{sm}_nucflag.bed",
        )
    run:
        with (
            open(input.bed) as fh,
            open(output.bed, "wt") as ofh
        ):
            for line in fh:
                chrom, st, end, mtype = line.strip().split()
                st, end = int(st) + 1, int(end) + 1
                st, end = str(st), str(end)
                orow = [
                    chrom,
                    st,
                    end,
                    mtype,
                    "0",
                    ".",
                    st,
                    end,
                    MTYPES[mtype]
                ]
                ofh.write("\t".join(orow) + "\n")

rule merge_first_bigwigs:
    input:
        chkpt=rules.check_asm_nucflag.output,
        cov_dir=rules.check_asm_nucflag.output.cov_dir,
    output:
        bw=os.path.join(config["output_dir"], "{sm}_first.bw"),
    conda:
        "env/tools.yaml"
    params:
        fglob="*_first.bw"
    shell:
        """
        bigwigmerge -l <(find {input.cov_dir}/ -name "{params.fglob}") {output.bw}
        """

use rule merge_first_bigwigs as merge_second_bigwigs with:
    output:
        bw=os.path.join(config["output_dir"], "{sm}_second.bw"),
    params:
        fglob="*_second.bw"


"""
upload_folder \
    {sample_id}/hprc_r2/assembly_qc/nucflag \
        {assembly_id}.nucflag.first.bw
        {assembly_id}.nucflag.second.bw
        {assembly_id}.nucflag.bed
        {assembly_id}.nucflag.plots.tar.gz

So sample ID would be HG000099 and asssembly id would be HG00099_hap1_hprc_v1.0.1 (from the assembly index file; in the assembly id column)
"""

rule create_tarballs:
    input:
        first_bw = rules.merge_first_bigwigs.output.bw,
        second_bw = rules.merge_second_bigwigs.output.bw,
        bedfile = rules.convert_nucflag_to_bed9.output,
        plot_dir = rules.check_asm_nucflag.output.plot_dir
    output:
        os.path.join(config["output_dir"], "{sm}.done")
    params:
        assembly_id="{sm}",
        # hprc_chry/assembly_qc/nucflag/
        tmp_dir=lambda wc: os.path.abspath(
            os.path.join(config["output_dir"], "final", wc.sm, "hprc_chry", "assembly_qc", "nucflag", f"{VERSION}_{DTYPE}")
        )
    conda:
        "env/tools.yaml"
    threads:
        4
    shell:
        """
        mkdir -p {params.tmp_dir}
        ln -sf $(realpath {input.first_bw}) {params.tmp_dir}/{params.assembly_id}.nucflag.first.bw
        ln -sf $(realpath {input.second_bw}) {params.tmp_dir}/{params.assembly_id}.nucflag.second.bw
        ln -sf $(realpath {input.bedfile}) {params.tmp_dir}/{params.assembly_id}.nucflag.bed
        plot_tarball=$(realpath "{params.tmp_dir}/{params.assembly_id}.nucflag.plots.tar.gz")
        pushd {input.plot_dir}
        tar -czf ${{plot_tarball}} *.png
        popd
        pushd {params.tmp_dir}
        ls | xargs -P {threads} -I {{}} bash -c "md5sum {{}} > {{}}.md5"
        popd
        touch {output}
        """



rule nucflag:
    input:
        expand(rules.check_asm_nucflag.output, sm=SAMPLE_INFO.keys()),
        expand(rules.convert_nucflag_to_bed9.output, sm=SAMPLE_INFO.keys()),
        expand(rules.merge_first_bigwigs.output, sm=SAMPLE_INFO.keys()),
        expand(rules.merge_second_bigwigs.output, sm=SAMPLE_INFO.keys()),
        expand(rules.create_tarballs.output, sm=SAMPLE_INFO.keys()),
    default_target: True
